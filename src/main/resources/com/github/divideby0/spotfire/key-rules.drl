package com.github.divideby0.spotfire

import org.optaplanner.core.api.score.buildin.bendable.BendableScoreHolder;
import com.github.divideby0.spotfire.domain.*;
import java.util.List;
import java.util.Set;
import com.wrapper.spotify.enums.Modality;

global BendableScoreHolder scoreHolder;

rule "identify SAME_KEY changes"
    salience 100
    when
    $key: Key()
    not KeyChange(fromKey == $key, toKey == $key)

    then
    KeyChange kc = new KeyChange($key, $key, KeyChangeType.SAME_KEY, 0);
    insert(kc);
end

rule "identify UP_FIFTH key changes"
    salience 100
    when
    $fromKey: Key($toRoot: fifth, $mode: mode)
    $toKey: Key(rootNote == $toRoot, mode == $mode)
    not KeyChange(fromKey == $fromKey, toKey == $toKey)

    then
    KeyChange kc = new KeyChange($fromKey, $toKey, KeyChangeType.UP_FIFTH, 1);
    insert(kc);
end

rule "identify DOWN_FIFTH key changes"
    salience 100
    when
    $fromKey: Key($toRoot: fourth, $mode: mode)
    $toKey: Key(rootNote == $toRoot, mode == $mode)
    not KeyChange(fromKey == $fromKey, toKey == $toKey)

    then
    KeyChange kc = new KeyChange($fromKey, $toKey, KeyChangeType.DOWN_FIFTH, 1);
    insert(kc);
end

rule "identify RELATIVE_MINOR key changes"
    salience 100
    when
    $fromKey: Key($toRoot: sixth, mode == Modality.MAJOR)
    $toKey: Key(rootNote == $toRoot, mode == Modality.MINOR)
    not KeyChange(fromKey == $fromKey, toKey == $toKey)

    then
    KeyChange kc = new KeyChange($fromKey, $toKey, KeyChangeType.RELATIVE_MINOR, 1);
    insert(kc);
end

rule "identify RELATIVE_MAJOR key changes"
    salience 100
    when
    $fromKey: Key($toRoot: second, mode == Modality.MINOR)
    $toKey: Key(rootNote == $toRoot, mode == Modality.MAJOR)
    not KeyChange(fromKey == $fromKey, toKey == $toKey)

    then
    KeyChange kc = new KeyChange($fromKey, $toKey, KeyChangeType.RELATIVE_MAJOR, 1);
    insert(kc);
end

declare TrackKeyChange
    currentTrack: SpotifyTrack
    previousTrack: SpotifyTrack
    position: Integer
    keyChange: KeyChange
end

rule "identify track key changes"
    salience 50
    when
    $kc: KeyChange(
        $fromKey: fromKey,
        $toKey: toKey,
        $type: type
    )
    $pt: PlaylistTrack(
        track != null,
        previousTrack != null,
        previousTrack.endKey == $fromKey,
        track.startKey == $toKey,
        $position: position,
        $currentTrack: track,
        $previousTrack: previousTrack
    )
    not TrackKeyChange(
        currentTrack == $currentTrack,
        previousTrack == $previousTrack,
        position == $position,
        keyChange == $kc
    )

    then
    TrackKeyChange tkc = new TrackKeyChange();
    tkc.setCurrentTrack($currentTrack);
    tkc.setPreviousTrack($previousTrack);
    tkc.setPosition($position);
    tkc.setKeyChange($kc);
    insert(tkc);
end



rule "Clear stale track key changes"
    when
    $tkc: TrackKeyChange(
        $currentTrack: currentTrack,
        $previousTrack: previousTrack
    )
    not PlaylistTrack(
        track == $currentTrack,
        previousTrack == $previousTrack
    )

    then
    retract($tkc);
end

rule "should not have unknown key changes"
    when
    PlaylistTrack(
        $currentTrack: track,
        $previousTrack: previousTrack
    )
    not TrackKeyChange(
        currentTrack == $currentTrack,
        previousTrack == $previousTrack
    )

    then
    scoreHolder.addSoftConstraintMatch(kcontext, 1, -80);
end

rule "first two transitions should have known key change"
    when
    PlaylistTrack(
        position <= 2,
        previousTrack != null,
        $position: position
    )
    not TrackKeyChange(
        position == $position
    )

    then
    scoreHolder.addSoftConstraintMatch(kcontext, 1, -8*20*(2-$position));
end

rule "first two transitions should be same key"
    when
    PlaylistTrack(
        position <= 2,
        previousTrack != null,
        $position: position
    )
    TrackKeyChange(
        position == $position,
        keyChange.type != KeyChangeType.SAME_KEY,
        $cost: keyChange.cost
    )

    then
    scoreHolder.addSoftConstraintMatch(kcontext, 1, -$cost*20*(2-$position));
end

rule "should maintain key momentum"
    when
    PlaylistTrack(
        position != null,
        $maxPosition: position,
        $minPosition: position - 5
    )
    $totalCost: Number(intValue > 2) from accumulate(
        TrackKeyChange(
            position <= $maxPosition,
            position > $minPosition,
            $cost: keyChange.cost
        ),
        sum($cost)
    )

    then
    scoreHolder.addSoftConstraintMatch(kcontext, 1, 2-$totalCost.intValue());
end

//declare SameKeyStreak
//    startPos: Integer
//    endPos: Integer
//    length: Integer
//end
//
//rule "identify same key streaks"
//    no-loop
//    when
//    TrackKeyChange(
//        $startPos: position
//    )
//    TrackKeyChange(
//        position > $startPos,
//        $endPos: position,
//        keyChange.type == KeyChangeType.SAME_KEY
//    )
//    not TrackKeyChange(
//        position > $startPos,
//        position < $endPos,
//        keyChange.type == KeyChangeType.SAME_KEY
//    )
//    not SameKeyStreak(
//        startPos == $startPos,
//        length > $endPos - $startPos
//    )
//
//    then
//    SameKeyStreak streak = new SameKeyStreak();
//    streak.setStartPos($startPos);
//    streak.setEndPos($endPos);
//    streak.setLength($endPos-$startPos);
//    insertLogical(streak);
//end
//
//rule "should not play same key more than 5 songs"
//    when
//    SameKeyStreak(
//        length > 5,
//        $length: length
//    )
//
//    then
//    scoreHolder.addSoftConstraintMatch(kcontext, 2, 5-$length);
//end
//
////rule "should play same key at least two songs in a row"
////    when
////    SameKeyStreak(
////        length < 3,
////        $length: length
////    )
////
////    then
////    scoreHolder.addSoftConstraintMatch(kcontext, 2, $length-3);
////end